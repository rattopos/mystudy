# 파이선 프로그래밍 - 김형신

## 시험
tree에서 나옴!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1

[Programs vs Algorithms](https://www.youtube.com/watch?v=9otrE0SyrFE)
[Practical Programming, 3e - 예스24](https://m.yes24.com/Goods/Detail/47526045)

## 함수

### 구조

```python
def <<functiion_name>>(<<parameters>>): # 1st line = function header
    <<function_body>>
```
- local variable: 함수 안에서 정의된 변수, 밖에서 사용 못함
- parameter: 변수임


### 함수 호출

1. 왼쪽부터 argument들을 계산.
2. local variable들을 담을 namespace를 만듦.
3. parameter들에 argument들의 값을 할당하면서 진행함
4. function body를 실행함. retun statement가 실행되면 함수가 끝남. 이때 retun statement 안의 expression의 값은 함수 호출의 값이 됨.

### if문

```python
if <<condition1>>:
    <<block1>>
elif <<condition2>>:
	<<block2>>
else:
	<<block3>>
```

- if의 block은 조건문이 참일 때만 실행됨
- elif의 block은 if의 조건문이 거짓이고 elif의 조건문이 참일때만 실행
- else는 위의 모든 경우가 거짓일 때 실행

### String Type

```python
'<<string>>'
"<<string>>"
```

- 작은 따옴표, 큰 따옴표 모두 가능
- string + string: concatenation
- string * num = repetition

다음과 같이 type 변환도 가능함
```python
int('1') # 1
float('3.14') # 3.14
str(5) # '5'
```

```python
a = input()
```

- 컴퓨터가 내가 무언가를 적을 때까지 기다림
- 무엇을 입력하든 파이썬은 이걸 string 값으로 저장함

```python
name = input("<<prompt>>")
```


## OOP

1. Encapsulation: Contain related information in an object
2. Abstraction: Hide details
3. Inheritance: Child classes inherit data and behaviors from parent class
4. Polymorphism: A single method acts in a different way depending on objects

## 2025-07-15

[Dynamic programming - Wikipedia](https://en.wikipedia.org/wiki/Dynamic_programming)

```python
def fibonacci(n:int) -> int:
	if n == 1 or n == 2: #conditional statements
		return n
	else:
		return fibonacci(n-1) + fibonacci(n-2)
```

GCD(24,60) = GCD(24,12) = GCD(12,0) return 12

[Array (data structure) - Wikipedia](https://en.wikipedia.org/wiki/Array_\(data_structure\))

[Linked list - Wikipedia](https://en.wikipedia.org/wiki/Linked_list)

[Sentinel value - Wikipedia](https://en.wikipedia.org/wiki/Sentinel_value)

[Stack (abstract data type) - Wikipedia](https://en.wikipedia.org/wiki/Stack_\(abstract_data_type\))

## 2025-07-22

모의면접 준비

array와 linked list 차이점

모범답

array는 주소가 다 붙어있어서 주소를 한번에 점프 할 수 있다.
따라서 접근속도가 빠르다. 하지만 크기를 변경하는 것에 제약이 크고 따라서 속도가 느리다. 정적인 구조에 데이터 유리함.

linked list는 각 항목은 다음 주소에 대한 정보를 가지고 있어야 한다. 메모리 하나만 빈 공간 찾으면 크기 변경이 빠르다. 읽어들이는 속도가 느리다.  동적인 데이터 구조에 유리함.

---

기술 면접 하는 이유
: 알고리즘을 아네 모르네 보단 사람의 다방면의 능력을 보는 것.

면접관의 문제가 이해가 안되면 바로 물어봐야 한다 안 그러면 이해했구나 하고 넘어간다. 상대가 말을 반복해도 괜찮다.

당장 생각은 못했지만 면접관이 feedback과 input을 주면 solution을 줄 수 있는가? Thinkout loud: 내 생각을 실시간으로 말로 표현을 해서 면접관이 내 머릿속이 어떻게 돌아가는지 알 수 있게 하는것.

> 같이 토론하면서 일하는 느낌이 중요한듯

코드를 고치기 전에 어떤 상황에서 반복되는지 정확히 알아내고 고쳐야 한다. (ppt 15p.)

모의면접

양의 정수만으로 주어진 list input 
target value: 자연수

리스트의 자연수를 2개를 뽑아서 더하면 타겟밸류가 나오게

```python
def twoSum(L:list,target:int)->list:
	for i in L:
		if target - i in list
		return i, target
	else:
		print("Error")
```

```python
def twoSum(L:list,target:int) -> list:
	dict = {}
	for i in [1:len(L)+1]:
		dict[L[i]] = i
		if target - i in dict:
			return [dict[i],dict[target-L[i]]]
```

## 2025-07-23

[Tree (abstract data type) - Wikipedia](https://en.wikipedia.org/wiki/Tree_\(abstract_data_type\))

[Binary search tree - Wikipedia](https://en.wikipedia.org/wiki/Binary_search_tree)

tree

rooted

binary

search

아래 구현해보기

```python
class TreeNode():
	def __init__(self, x:int):
	self.val = x
	self.left = None
	self.right = None

class BST():
	def __init__(self):
	self.root = None
	
	def __searchHelp(self, curNode: TreeNode, x:int) -> TreeNode:
		if not curNode:
			return None
		if x == curNode.val:
			return curNode
		elif x < curNode.val:
			return self.__searchHelp(curNode.left, x)
		else:
			return self.__searchHelp(curNode.right, x)
	def search(self, x:int) -> TreeNode:
		return self.__searchHelp(self.root, x)

	def __insertHelp(self,curNode:TreeNode, x:int) -> TreeNode:
		if not curNode:
			return TreeNode(x)
		if x < curNode.val:
			curNode.left = self.__insertHelp(curNode.left, x)
		elif x > curNode.val:
			curNode.right = self.__insertHelp(curNode.right, x)
		return curNode
	def insert(self, x:int) -> None:
		self.root = self.__insertHelp(self.root, x)
	
	def delete(self, x:int)
	# 수업에서 구현을 다루지 않는다
	
	# case 1: Delete a leaf node
	# simply cut the parent's link
	
	# case 2: Delete a node with one child
	# search the node using its key value
	# cut the prent's link to the target
	# 
	# Case 3: Delete a node with two children
	# search the node using its key value
	# either the rightmost node in the left subtree or the leftmost node in the right subtree
```

[Self-balancing binary search tree - Wikipedia](https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree)

```python
# Level-order (Breadth-First) Traversal
class Tree():
	def visit(self, node: TreeNode):
		print(node.val)
	def BFT(self):
		if self.root == None
			return
		q = [self.root]
		while q:
			curNode = q.pop(0)
			self.visit(curNode)
			for childNode in curNode.child:
				if childNode:
					q.append(childNode)
```

```python
# Level-order (Breadth-First) Traversal
class Tree():
	def visit(self, node: TreeNode):
		print(node.val)
	def BFT(self):
		if self.root == None
			return
		q = deque[self.root]
		while q:
			curNode = q.pop(0)
			self.visit(curNode)
			for childNode in curNode.child:
				if childNode:
					q.append(childNode)

```

---

SW 개발자 직군 면접에서 자주 출제하는 내용
1. dynamic programming (수업에선 안 다룸)
2. graph (traversal code를 잘 짜야함)

## 2025-08-04

### File

```python
file = open(file_name, mode) # mode: 'r', 'w', 'a'
file.read()
file.close()
```

```python
with open('file_name', 'r') as file:
	contents = file.reade()
```

```python
import os
os.getcwd()
os.chdir('dir')
```

| method          | desc                               |
| --------------- | ---------------------------------- |
| readline()      | read a line.                       |
| strip()         | remove \n character.               |
| split()         | break a line into a list of words. |
| decode('utf-8') | decode the file by utf-8.          |

### OOP

| notion        | desc                                                                                    |
| ------------- | --------------------------------------------------------------------------------------- |
| encapsulation | contain related info in an object                                                       |
| abstraction   | hide details                                                                            |
| inheritance   | inherit data and behaviors from parent class                                            |
| polymorphsim  | allow a single method to do different things depending on what object it is included in |

### graph

graph = node + edge

#### tree

only one path between two nodes in a tree

#### rooted tree

- exactly one root node
- every non-root node has one parent
- node w/o a child is a leaf

#### rooted binary tree
- each node has at most two children nodes

#### binary search tree

- for every node x, x's value is unique
- every node y in left subtree of node x, y < x
- every node z in right subtree of node x, z>x

### Graph

### Array

an array is an object comprising a numbered sequence of memory boxes.

an array comprises
- fixed integer length N
- a sequence of N memory boxes ( from 0 to N-1 )

limitation: fixed length and expensive resizing
improvement: resizing step adjustment

#### Linked List

```python
class LinkedNode():
	def __init__(self,x):
		self.val = x
		self.next = None

a = LinkedNode(5) # node a에 5 값을 부여
b = linkedNode(7) # node b에 7 값을 부여
a.next = b # a가 가리키는 다음 node를 b로 설정
```

limitation: donno what is where
improvement: caching and sentinel

### queue

FIFO

| methods   | desc                             |
| --------- | -------------------------------- |
| enqueue() | add an elt to the queue          |
| dequeue() | remove the oldest elt from queue |

### stack

LIFO

| methods | desc                                 |
| ------- | ------------------------------------ |
| push()  | add and elt to the stack             |
| pop()   | remove the newest elt from the stack |

### Algorithm

#### Search

linear serach: O(N)
binary search: O(log N), applicable to a sorted list

#### Sort

selection sort:
- find the minimum value of the unsorted list and swap it with the leftmost entry.
- O(N<sup>2</sup>)

insertion sort
- insert the leftmost item of the unsorted list to the proper location of the sorted list.
- O(N<sup>2</sup>) a bit lower than selection sort.
- when a list is a most sorted, O(N)

merge sort
- split list into two sublist, sort, and merge.
- time complexity: O(N log N)
- memory complexity: O(N)

[Federated learning - Wikipedia](https://en.wikipedia.org/wiki/Federated_learning)

open-set learning